
\newcommand{\lrangle}[1]{\langle{#1}\rangle}
\newcommand{\effchk}[1]{\mathbf{chk}\lrangle{#1}}
\newcommand{\effend}[1]{\mathbf{end}\lrangle{#1}}

\newcommand{\mKey}{\mathit{Key}}
\newcommand{\mPub}{\mathit{Pub}}
\newcommand{\mgen}{\mathit{gen}}
\newcommand{\pFN}{\mathit{FN}}
\newcommand{\mCh}{\mathit{Ch}}

\newcommand{\eraserf}[1]{\lfloor {#1} \rfloor}

\newcommand{\ldenotation}{\llbracket}
\newcommand{\rdenotation}{\rrbracket}
\newcommand{\denotation}[1]{\ldenotation {#1} \rdenotation}

\newcommand{\rty}[2]{\{v {:}\mathbf{N}({#1}) ~|~ {#2}\}}
\newcommand{\passert}[2]{\mathit{assert}({#1}).{#2}}

\newcommand\Code[1]{{\tt #1}}
\newcommand{\nut}[2]{\{ v{:}{\Code{#1}}\, |\, {#2} \}}
\newcommand{\assertP}[1]{\mathbf{assert}\ {#1}}
\newcommand{\letP}[3]{\mathbf{let}\;{#1} = {#2}\;\mathbf{in}\;{#3}}
\newcommand{\newP}[1]{(\nu {#1})}
\newcommand{\decryptP}[3]{\textbf{decrypt }{#1}~is~\{{#2}\}_{#3}}
\newcommand{\splitP}[3]{\textbf{split }{#1}~is~ ({#2},{#3})}
\newcommand{\checkP}[1]{\textbf{check }{#1}}
% \newcommand{\checknotP}[2]{\textbf{check }{#1}~is~not~{#2}}

\newcommand{\keyT}[1]{\Code{Key}({#1})}
\newcommand{\chT}[1]{\Code{Ch}({#1})}
\newcommand{\rawnuot}[2]{\{v{:}{#1} \;|\; {#2}\}}
\newcommand{\nuot}[2]{\rawnuot{\Code{#1}}{#2}}


\newcommand{\ctx}[2]{{#1}{\;|\;}{#2}}
\newcommand{\langname}{$\phi_\mathbb{Z}$-calculus}
\newcommand{\chq}{\Code{ch_{quote}}}
\newcommand{\chr}{\Code{ch_{result}}}
\newcommand{\price}{\Code{p}}
\newcommand{\costprice}{\Code{p_{cost}}}
\newcommand{\exprice}{\Code{p_{expected}}}
\newcommand{\nonce}{\Code{n}}
\newcommand{\zero}{\mathtt{O}}
\newcommand{\success}{``Succ"}
\newcommand{\fail}{``Fail"}
\newcommand{\Ch}{\Code{Ch}}
\newcommand{\key}{\Code{Key}}
\newcommand{\iteP}[3]{\textbf{if}\ {#1}\ \textbf{then}\ {#2} \ \textbf{else}\ {#3}}





\documentclass[master,english]{kuisthesis}
\usepackage[english]{babel}
\usepackage{amsthm, amssymb}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]


% Useful packages
\usepackage{wrapfig, amsthm, pict2e, booktabs, subcaption, subfiles, rotating, pifont, indentfirst, amsmath, mathbbol, amsfonts, mathrsfs, adjustbox, mathtools,booktabs, microtype, ebproof, enumitem, multirow, multicol, setspace, hyperref, xcolor, lineno, listings, stmaryrd, xspace, stackengine}
\usepackage{empheq}
\newcommand*\widefbox[1]{\fbox{\hspace{2em}#1\hspace{2em}}}
\usepackage[tableposition=top]{caption}
\usepackage{tikz-cd}
\usetikzlibrary{decorations.pathmorphing}
\usepackage[ruled,linesnumbered,vlined]{algorithm2e}
\usepackage{graphicx}
\urlstyle{same}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{minted}
\usemintedstyle{borland}
\usepackage{tikz}
\newcounter{markeq}
\setcounter{markeq}{0}
\usepackage{spacingtricks}
\newcommand*\tstrut[1]{\vstrut{#1}}
\newcommand*\bstrut[1]{\vstrut[#1]{0pt}}
\usepackage[T1]{fontenc}
\newcommand*\mystrut[1]{\vrule width0pt height0pt depth#1\relax}
\usepackage{graphicx}
\usepackage{verbatim}


\def\LATEX{{\rm (L\kern-.36em\raise.3ex\hbox{\sc a})\TeX}}
\def\LATex{\iLATEX\small}
\def\iLATEX#1{L\kern-.36em\raise.3ex\hbox{#1\bf A}\kern-.15em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}
\def\LATEXe{\ifx\LaTeXe\undefined \LaTeX 2e\else\LaTeXe\fi}
\def\LATExe{\ifx\LaTeXe\undefined \iLATEX\scriptsize 2e\else\LaTeXe\fi}
\let\EM\bf
\def\|{\verb|}
\def\<{\(\langle\)}
\def\>{\(\rangle\)}
\def\CS#1{{\tt\string#1}}

\jtitle[特別研究報告書執筆の手引]%	% Japanese title to be output in the abstract and the table of contents.
	{特別研究報告書執筆の手引}	% Japanese title to be output in the title page.
\etitle{Refinement Types for Linear Spi-Calculus}	% English title.
\eauthor{Wang Yi}			% Author name in English
\supervisor{ }			% Name of the supervisor

%%%%%%% Name of the department.  (Ignored if you are writing senior thesis.)
\department{Communications and Computer Engineering}
%\department{Intelligence Science and Technology}
%\department{Social Informatics}

%%%%%%% Date of submission
\date{June 12th, 2024} 

\begin{document}

\maketitle					% Output title page

\begin{eabstract}				% Abstract in English

  In modern e-commerce and financial transactions, communication protocols play a crucial role in ensuring the security and accuracy of information exchange. Traditional protocols, often based on pi-calculus and spi-calculus, struggle to handle complex applications such as pricing systems where the relationships between numbers are vital for system correctness. These protocols also face issues such as server overload due to the reusable nature of channels.




Refinement types improve the expressiveness of the type system by allowing for the precise specification of properties beyond those of simple types. For example, using refinement types, we can specify that a particular integer must be greater than or less than a certain value, thereby enabling the verification of complex logical conditions. 

This paper proposes an improved type system based on spi-calculus, incorporating refinement types. Traditionally, spi-calculus could only transmit string-type information. In the new type system, spi-calculus is allowed to transmit integer-type information. By introducing refinement types, it enables comparisons between numeric values and the expression of more complex properties, which are essential for applications requiring detailed numerical analysis. Additionally, programmers are allowed to insert assertions at any point in the system, enhancing the flexibility and robustness of the verification process. To express protocols that involve communication of different types, we incorporate linear channels into our type system. By using linear channels, we can guarantee that each channel is used only once, which prevents server overload and ensures the accuracy and integrity of message transmission. 

As a case study, this paper applied our type system to verify the properties of a protocol used in a pricing system, demonstrating its practical applicability. Finally, through type soundness proofs, we demonstrate that our refined type system significantly improves the accuracy and reliability of communication protocols in pricing systems. 




%\par\bigskip\centerline{\bf NOTE}
%\begin{quote}
% This guide is translated from the original Japanese version in order to provide an example written in English.  Although you may regardthis guide as giving the same guidelines and instructions which theJapanese version gives, remember that the Japanese version is solelyand formally established by the Department.
%\end{quote}
\end{eabstract}



\tableofcontents				% Output table of contents

\section{Introduction}\label{sec-intro}		% Here the main text starts

\paragraph{Background}

In the realm of concurrent communication, designing and implementing secure communication protocols is a critical challenge. to ensure the security and safety of communications, various protocols have been defined. However, these protocols are often difficult to understand and implement correctly. Even in relatively simple protocols, very subtle errors can occur, potentially leading to severe security vulnerabilities and system failures. For example, Abadi and Needham (1996) discussed several practical issues in the design of cryptographic protocols in their study, demonstrating that even well-known protocols can harbor subtle yet serious flaws \cite{?}.


Pi-calculus is a mathematical model used to describe and analyze communication protocol. Developed by Robin Milner in the early 1990s \cite{?}, pi-calculus allows the representation of processes that can change their structure during execution. It extends the capabilities of earlier process calculi by introducing the concept of channel names as first-class citizens, enabling dynamic communication topologies. Pi-calculus provides a robust framework for modeling and reasoning about the behavior of complex systems, particularly those involving mobile and dynamic communication patterns. Its theoretical foundation has been influential in the design of various communication protocols and verification methods.

Pi-calculus has security issues because it lacks mechanisms for securely handling and encrypting messages, which is why spi-calculus was introduced to enhance security by incorporating cryptographic operations, spi-calculus extends $\pi$-calculus by incorporating symmetric key encryption to enhance message security\cite{?}. In spi-calculus, channels are generalized, and messages are encrypted to effectively prevent unauthorized access and tampering. Spi-calculus supports the transmission of names and channels and introduces encryption and decryption operations, enabling the modeling and analysis of complex security protocols. By using encryption, spi-calculus ensures that in an open communication environment, only authorized entities can access and manipulate the transmitted information, significantly enhancing communication security \cite{?}.

However, protocol verification cannot handle some of the more commonly used but complex applications today, such as pricing systems. In modern e-commerce and financial transactions, pricing systems play a crucial role. These systems are used to determine the transaction prices between buyers and sellers, serving as a core mechanism in market trading. In such systems, buyers need to obtain sellers' quotes and compare them with their own expected prices to make informed trading decisions. Due to price fluctuations and changing market conditions, timely and accurate transmission of pricing information is vital for both buyers and sellers.
Moreover, the accuracy and security of pricing systems directly impact the fairness and transparency of transactions. If pricing information is distorted or maliciously tampered with during transmission, it could lead to unfair trades and harm the interests of market participants. Therefore, ensuring that communication protocols within pricing systems can reliably and accurately transmit information while preventing malicious attacks is essential for the proper functioning of the market.

\paragraph{Challenges}
1. In pricing systems, the relationships between numbers are very important, and programmers need such relationships to ensure system correctness. Spi-calculus can not express these relationships.

2. In pricing systems, it is crucial for buyers and sellers to successfully transmit messages to each other. However, in Spi-calculus channels can be used multiple times, which may lead to message distortion.


\paragraph{Exsiting work}
To prevent these issues, researchers have developed both static and dynamic methods. For instance, one dynamic approach is the use of corresponding assertions. This technique involves inserting assertions into the program to ensure consistency and correctness of communication and data between different threads. Corresponding assertions check specific conditions at runtime, capturing potential concurrency errors by inserting assertions at critical communication points, ensuring that any inconsistencies or potential issues can be detected promptly \cite{?}. This method is advantageous due to its flexibility and real-time monitoring capabilities, allowing developers to dynamically monitor and verify the correctness of communications during execution.

Another method is session types. This static approach defines type systems for communication protocols, ensuring that communication follows a predefined pattern. Session types can detect many potential errors at compile-time, thereby enhancing the security and reliability of the system. Session types not only define the structure and sequence of communications but also allow for static analysis of data flows, ensuring that interactions between different processes adhere to the predefined protocol specifications. This method's advantage lies in its ability to identify and correct errors during compilation, preventing many runtime errors \cite{?}.





\paragraph{Solutions}

By introducing a new communication protocol language that can easily express complex relationships between variables, we can better ensure the correctness and security of the system. This new method can not only address the limitations of existing methods but also improve the understanding and implementation accuracy of communication protocols.

Based on spi-calculus, I have constructed a type system that incorporates both refinement types and linear channels. In this system, users can freely insert assertions, making it easier to describe the protocols they consider correct.





\section{Overview}\label{sec-structure}
\subsection{Motivating Example}
\begin{align*}
    \Code{System(k,ch, \costprice)} \doteq&\  \Code{Buyer(k,ch,\costprice)} \  || \  \Code{Seller(k,ch, \costprice)}
    \\\Code{Buyer(k,ch, \costprice)} \doteq&\  \Code{ch}?(\nonce, \chq).\newP{\price}.\newP{\chr}.\chq!\{(\nonce, \price, \chr)\}_\Code{k}.\chr?\Code{msg}.
    \\&\iteP{\Code{msg} = \success}{\assertP{\price > \costprice}.\zero}{\zero}
    \\\Code{Seller(k,ch, \costprice)} \doteq&\ \newP{\exprice}.\newP{\nonce}.\newP{\chq}.\Code{ch}!(n, \chq).\chq?\Code{cmsg}.
    \\&\decryptP{\Code{cmsg}}{(\Code{n'}, \price, \chr)}{\Code{k}}.\checkP{\Code{n} = \Code{n'}}.
    \\&\iteP{\price < \costprice \lor \price < \exprice}{\chr!\fail.\zero}{\chr!``Succ''.\mathtt{O}}
\end{align*}

\subsection{Type Judgement}
\paragraph{Syntax Sugar}

\begin{align*}
    \Code{ch}?(x, y).P \doteq&\ \Code{ch}?M.\splitP{M}{x_1}{x_2}.P
    \\\iteP{\phi}{P_1}{P_2} \doteq&\ \checkP{\phi}.P_1 ~||~ \checkP{\neg \phi}.P_2
    \\\decryptP{\Code{c}}{(x, y)}{\Code{k}}.P \doteq&\ \decryptP{\Code{c}}{M}{\Code{k}}.\splitP{M}{x}{y}.P
    \\\Code{b} \doteq& \ \rawnuot{b}{\top}
\end{align*}

{\small
\begin{align*}
    \tau_{r} \doteq&\ \nut{string}{
\price > \costprice {\implies}
 v = \success \land
\price \leq \costprice {\implies} 
v = \fail \land (v = \success \lor v = \fail)  }
    \\\tau_{q}(n,\Code{k}) \doteq&\ \{\nut{nonce}{v = n} \times \Code{int} \times \Ch(\tau_{r})\}_{\nut{key(int)}{v = \Code{k}}}
    \\\tau_{c}(\Code{k}) \doteq&\ n{:}\Code{nonce} \times \Ch(?,\tau_{q}(n, \Code{k}))
    \\\Gamma_1 \doteq&\  \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce}
    \\\Delta_1 \doteq&\ \chq{:}\Ch(!,\tau_{q}(n, \Code{k}))
    \\\Gamma_2 \doteq&\  \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce}, \price{:}\Code{int}
    \\\Delta_2 \doteq&\ \chq{:}\Ch(!,\tau_{q}(n, \Code{k})), \chr{:}\Ch(?,\tau_{r})
    \\\Gamma_3 \doteq&\ \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce}, \price{:}\Code{int} 
    \\\Delta_3 \doteq&\ \chr{:}\Ch(?,\tau_{r})
    \\\Gamma_4 \doteq&\ \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce}, \price{:}\Code{int}, \Code{msg}{:}\tau_{r}
    \\\tau_{true} \doteq&\ \nut{string}{(
\price > \costprice {\implies}
 v = \success \land
\price \leq \costprice {\implies} 
v = \fail \land (v = \success \lor v = \fail)) \land v = \success}
    \\\Gamma_5 \doteq&\ \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce}, \price{:}\Code{int}, \Code{msg}{:}\tau_{true}
    \\\tau_{false} \doteq&\ \nut{string}{( 
\price > \costprice {\implies}
 v = \success \land
\price \leq \costprice {\implies} 
v = \fail \land (v = \success \lor v = \fail)) \land v \not= \success}
    \\\Gamma_6 \doteq&\ \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce}, \price{:}\Code{int}, \Code{msg}{:}\tau_{false}
\end{align*}}

{\small
\begin{prooftree}
\hypo{
\parbox{85mm}{\center
  $\models ((
\price > \costprice {\implies}
 v = \success \land
\price \leq \costprice {\implies} 
v = \fail$ \\
$\land (v = \success \lor v = \fail)) \land v = \success) \implies \price > \costprice$
}
}
\infer1[\textsc{}]{
\parbox{70mm}{\center
  $\Gamma_5 ~|~ \emptyset \vdash \assertP{\price > \costprice}.\zero$
}
}
\hypo{
\parbox{20mm}{\center
  $\Gamma_6 ~|~ \emptyset \vdash \zero$
}
}
\infer2[\textsc{T-Par}]{
\parbox{110mm}{\center
  $\Gamma_4 ~|~ \emptyset \vdash \checkP{\Code{msg} = \success}.\assertP{\price > \costprice}.\zero ~||~
  \checkP{\Code{msg} \not= \success}.\zero$ \\
$Linear(\eraserf{\tau_{r}}) \quad \chr{:}\Ch(?,\tau_{r})  \vdash \chr{:}\Ch(?,\tau_{r}) $
}
}
\infer1[\textsc{T-In2}]{
\parbox{100mm}{\center
  $\Gamma_3 ~|~ \Delta_3 \vdash \chr?\Code{msg}.\iteP{\Code{msg} = \success}{\assertP{\price > \costprice}.\zero}{\zero}$ \\ 
  $\Gamma_2 ~|~ \Delta_2 \vdash \{(\nonce, \price, \chr)\}_\Code{k}: \tau_{q}(n,\Code{k})$
}
}
\infer1[\textsc{T-Out}]{
\Gamma_2 ~|~ \Delta_2\vdash \chq!\{(\nonce, \price, \chr)\}_\Code{k}.\chr?\Code{msg}...
}

\infer1[\textsc{T-New2}]{
\parbox{80mm}{\center
$\Gamma_1 ~|~ \Delta_1 \vdash \newP{\price}.\newP{\chr}.\chq!\{(\nonce, \price, \chr)\}_\Code{k}....$\\
$Linear(\eraserf{\tau_{q}(n, \Code{k}}) \quad
\Code{ch}{:}\Ch(\tau_{c}(\Code{k}))\vdash \Code{ch} : \Ch(\tau_{c}(\Code{k}))$
}
}
\infer1[\textsc{T-In2}]{
\Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{ch}{:}\Ch(\tau_{c}(\Code{k})) \vdash \Code{ch}?(\nonce, \chq).\newP{\price}.\newP{\chr}....
}
\end{prooftree}
}


{\small
\begin{align*}
    \tau_{r} \doteq&\ \nut{string}{
\price > \costprice {\implies}
 v = \success \land
\price \leq \costprice {\implies} 
v = \fail \land (v = \success \lor v = \fail)  }
    \\\tau_{q}(n,\Code{k}) \doteq&\ \{\nut{nonce}{v = n} \times \Code{int} \times \Ch(\tau_{r})\}_{\nut{key(int)}{v = \Code{k}}}
    \\\tau_{c}(\Code{k}) \doteq&\ n{:}\Code{nonce} \times \Ch(!,\tau_{q}(n, \Code{k}))
    \\\Gamma_1 \doteq&\  \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce},\exprice{:}\Code{int}
    \\\Delta_1 \doteq&\ \Code{ch}{:}\Ch(\tau_{c}(\Code{k})), \chq{:}\Ch(?,\tau_{q}(n, \Code{k}))
    \\\Gamma_2 \doteq&\  \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce},\exprice{:}\Code{int}
    \\\Delta_2 \doteq&\ \chq{:}\Ch(?,\tau_{q}(n, \Code{k})) 
    \\\Gamma_3 \doteq&\  \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce},\exprice{:}\Code{int}
    \\\Delta_3 \doteq&\ \Code{cmsg}{:}\{\nut{nonce}{v = n} \times \Code{int} \times \Ch(!,\tau_{r})\}_{\nut{key(int)}{v = \Code{k}}}
    \\\Gamma_4 \doteq&\  \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce},\exprice{:}\Code{int}, \Code{n'}{:}\nut{nonce}{v = n}, \Code{p}{:}\Code{int}
    \\\Delta_4 \doteq&\  \chr{:}\Ch(!,\tau_{r})
    \\\tau_{true} \doteq&\ \nut{unit}{\price < \costprice \lor \price < \exprice}
    \\\Gamma_5 \doteq&\ \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce}, \exprice{:}\Code{int}, \Code{n'}{:}\nut{nonce}{v = n}, \Code{p}{:}\Code{int}, \chr{:}\Ch(!,\tau_{r}), \Code{\_}{:}\tau_{true}
    \\\Gamma_5' \doteq&\ \Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{n}{:}\Code{nonce}, \exprice{:}\Code{int}, \Code{n'}{:}\nut{nonce}{v = n}, \Code{p}{:}\Code{int}, \Code{\_}{:}\tau_{true}
\end{align*}}

{\small
\begin{prooftree}
\hypo{
}
\infer1[\textsc{T-Var}]{
\parbox{60mm}{\center
  $\Gamma_5' \vdash \fail : \nut{string}{v = \fail}$ \\ 
  $\models \forall \price...\forall v. \price < \costprice \lor \price < \exprice \implies$
  \\$(v = \fail \implies (\price > \costprice {\implies} ...))$
}
}
\infer1[\textsc{T-Sub}]{
\Gamma_5' ~|~ \emptyset  \vdash \fail : \tau_r
}
\hypo{
\Gamma_5 ~|~ \emptyset \vdash \chr : \Ch(!,\tau_{r})
}
\hypo{
}
\infer1[\textsc{T-Zero}]{
\Gamma_5'~|~ \emptyset \vdash \zero
}
\infer3[\textsc{T-Out}]{
\Gamma_5 ~|~ \emptyset \vdash \chr!\fail.\zero
}
\infer1[\textsc{T-Par}]{
\Gamma_4 ~|~ \Delta_4  \vdash \iteP{\price < \costprice \lor \price < \exprice}{\chr!\fail.\zero}{\chr!``Succ''.\mathtt{O}}
}
\infer1[\textsc{T-Check}]{
\Gamma_4 ~|~ \Delta_4  \vdash \checkP{\Code{n} = \Code{n'}}....
}
\infer1[\textsc{T-Decript}]{
\Gamma_3 ~|~ \Delta_3 \vdash \decryptP{\Code{cmsg}}{(\Code{n'}, \price, \chr)}{\Code{k}}.\checkP{\Code{n} = \Code{n'}}....
}
\infer1[\textsc{T-In2}]{
\parbox{60mm}{\center
$\Gamma_2 ~|~ \Delta_2 \vdash \chq?\Code{cmsg}.....$ \\
$\Code{ch}{:}\Ch(\tau_{c}(\Code{k}))\vdash \Code{ch} : \Ch(\tau_{c}(\Code{k})) $
}
}
\infer1[\textsc{T-Out}]{
\parbox{60mm}{\center
$\Gamma_1 ~|~ \Delta_1 \vdash \Code{ch}!(n, \chq).\chq?\Code{cmsg}.....$ 
} 
}
\infer1[\textsc{T-New2}]{
\Code{k}{:}\keyT{\Code{string}},\costprice{:}\Code{int},\Code{ch}{:}\Ch(\tau_{c}(\Code{k})) \vdash \newP{\exprice}.\newP{\nonce}....
}
\end{prooftree}
}

\section{Language}\label{sec-structure}
\subsection{Syntax}
\begin{figure}[h!]
\centering
{\small
    \begin{alignat*}{2}
    \text{\textbf{Variables}}& \quad &\quad& x, y, z, f, ...
    \\\text{\textbf{Qualifiers}} & \quad & \phi ::= \quad & \bot ~|~ \top ~|~ M_1 = M_2 ~|~ M_1 < M_2 ~|~  \neg \phi ~|~ \phi \land \phi ~|~ \phi \lor \phi
    \\\text{\textbf{Messgae}} & \quad & K, M, N ::= \quad &  x ~|~ (M, N) ~|~ \{M\}_K ~|~ \mathbb{n}
    \\\text{\textbf{Process}} & \quad & P, Q ::= \quad & \mathbf{0} ~|~ \letP{x}{M}{P} ~|~ x!y.P ~|~ x?y.P  ~|~ \assertP{\phi}.P ~|~(P_1 ~||~ P_2) ~|~ \newP{x}P \\
   &\quad&\quad& ~|~ \newP{cx}P ~|~ \decryptP{M}{x}{K}.P ~|~ \splitP{M}{x}{y}.P 
    ~|~ \checkP{\phi}.P
  \end{alignat*}
}
    \caption{Synatx of \langname{}.}
    \label{fig:synatx}
\end{figure}

To formalize our approach, we first introduce \langname{} shown in \autoref{fig:synatx}, an extension of $\phi$-calculus with numerical safety assertions.

\subsection{Operational Semantics}

\begin{figure}[h!]
\centering
\begin{align*}
\langle\Psi \uplus\{x?y.P_1, x!z.P_2\}, N, C\rangle &\longrightarrow \langle\Psi \uplus\{[z / y]P_1, P_2\}, N, C \setminus \{x\}\rangle \\
\langle\Psi \uplus\{P \mid Q\}, N, C\rangle &\longrightarrow\langle\Psi \uplus\{P, Q\}, N, C\rangle \\
\langle\Psi \uplus\{(\nu x) P\}, N, C\rangle &\longrightarrow\langle\Psi \uplus\{[y / x] P\}, N \cup \{y\}, C\rangle \quad \text{ $y$ is fresh}\\
\langle\Psi \uplus\{(\nu_C x) P\}, N, C\rangle &\longrightarrow\langle\Psi \uplus\{[y / x] P\}, N, C \cup \{y\}\rangle \quad \text{ $y$ is channel}\\
\langle\Psi \uplus\{\text { \textbf{check} } \phi . P\} , N, C\rangle &\longrightarrow \langle\Psi \uplus\{P\} , N, C\rangle \quad \text{where $\phi$ holds}\\
\langle\Psi \uplus\{\text { \textbf{check} } \phi . P\}, N, C\rangle &\longrightarrow \langle\Psi, N, C\rangle \quad \text{where $\phi$ not holds} \\
\langle\Psi \uplus\{\text { \textbf{assert} } \phi . P\} , N, C\rangle&\longrightarrow \langle\Psi \uplus\{P\}, N, C\rangle \quad \text{when $\phi$ holds} \\
\langle\Psi \uplus\{\text { \textbf{assert} } \phi . P\}, N, C\rangle &\longrightarrow \textbf{AssertFailure} \quad \text{when $\phi$ doesn't hold} \\ 
\langle\Psi \uplus\{ \text{\textbf{decrypt}}\ \{M\}_K
\text{ is } \{x\}_K . P\} , N, C\rangle &\longrightarrow\langle\Psi \uplus\{[M / x] P\} , N, C \rangle\\
\langle\Psi \uplus\{ \text{\textbf{decrypt}}\ \{M\}_K
\text{ is } \{x\}_{K'} . P\} , N, C\rangle &\longrightarrow\langle\Psi, N, C\rangle \quad \text{where $K \not= K'$} \\
\langle\Psi \uplus\{ \text{\textbf{split}}\ (M_1, M_2)
\text{ is } (x, y) . P\}, N, C\rangle &\longrightarrow\langle\Psi \uplus\{[M_2 / y][M_1 / x] P\}, N, C \rangle\\
\end{align*}
    \caption{Operational Semantics}
    \label{fig:semantics}
\end{figure}

The small-step operational semantics of \langname{} is given in \autoref{fig:semantics}, where $\Psi$ is a multiset of processes, N is a set of names,C is a set ofchannels. We write $\Psi_1 \to \Psi_2$ if process set $\Psi_1$ reduce to process set $\Psi_2$ in one step; we write $\to^*$ for
the reflexive and transitive closure of $\to$.

\paragraph{Safety} A process P is safe iff $\langle\{P\}, \emptyset, \emptyset\rangle \not\longrightarrow^* \textbf{AssertFailure} $ .


\section{Typing}\label{sec-structure}
\subsection{Types}

\begin{figure}[h!]
\centering
    \begin{alignat*}{2}
    \text{\textbf{Base Types}}& \quad & b ::= \quad & \Code{nonce} ~|~ \Code{int} ~|~ \Code{string} ~|~ ...\\
    \text{\textbf{Use}}& \quad & u ::= \quad & ? ~|~ ! ~|~ \ddagger \\
    \text{\textbf{Basic Types}}& \quad & t ::= \quad & b ~|~  \chT{t, u} ~|~ t \times t ~|~ \{t\}_t ~|~ \keyT{t} \\
    \text{\textbf{Refinement Types}}& \quad & \tau ::= \quad & \rawnuot{b}{\phi} ~|~ \chT{\tau, u } ~|~ x{:}\tau \times \tau ~|~ \{\tau\} ~|~ \keyT{\tau}  \\
    \text{\textbf{Type Context}}& \quad & \Gamma|\Delta ::= \quad & \emptyset ~|~ x{:}\tau, \Gamma|\Delta  ~|~  \Gamma|x{:}\tau, \Delta  \\
  \end{alignat*}
    \caption{Type Syntax.}
    \label{fig:type-syntax}
\end{figure}

The syntax of the refinement type is shown in \autoref{fig:type-syntax}.

\ \\ \ \\
\begin{prooftree}
\hypo{}
\infer1[\textsc{}]{
Linear(\chT{t, u})
}
\end{prooftree}

\ \\ \ \\ 
\begin{prooftree}
\hypo{
Linear(t_1) \quad Linear(t_2)
}
\infer1[\textsc{}]{
Linear(t_1\times t_2)
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{
Linear(t')
}
\infer1[\textsc{}]{
Linear(\{t'\})
}
\end{prooftree}
\ \\ \ \\ 
$Nonlinear(t)$  can be defined as $\neg Linear(t)$

\subsection{Typing Denotation}

\newcommand{\basicvdash}{\vdash_{\Code{basic}}}

\begin{flalign*}
  &\text{\textbf{Type Erasure}}
  & \fbox{$\eraserf{\tau} \in t$}
\end{flalign*}
\vspace{-1.5em}
{\small\begin{align*}
    \eraserf{\rawnuot{b}{\phi}} \doteq b \quad
    \eraserf{\chT{\tau}} \doteq \chT{\eraserf{\tau}} \quad
    \eraserf{\keyT{\tau}} \doteq \keyT{\eraserf{\tau}} \quad
    \eraserf{x{:}\tau_x \times \tau} \doteq \eraserf{\tau_x} \times \eraserf{\tau} \quad
    \eraserf{\{\tau\}} \doteq \{\eraserf{\tau}\}_{}
    \\
    \eraserf{\emptyset} \doteq \emptyset
    \quad 
    \eraserf{x{:}\tau,\Gamma} \doteq x{:}\eraserf{\tau},\eraserf{\Gamma}
\end{align*}
}
\begin{flalign*}
  &\text{\textbf{Type Context Denotation}}
  & \fbox{$\denotation{\Gamma} \in \phi $}
\end{flalign*}
\vspace{-1.5em}
{\small\begin{align*}
    \denotation{\emptyset} &\doteq \top
    \\\denotation{x{:}\rawnuot{b}{\phi}, \Gamma} &\doteq \phi[v \mapsto x] \land \denotation{\Gamma}
    \\\denotation{x{:}\tau, \Gamma} &\doteq \denotation{\Gamma} \quad \text{ when } \tau \not= \rawnuot{b}{\phi}
\end{align*}
}

\newcommand{\R}[1]{\Code{R}({#1})}


\subsection{Typing Rules}

$$
\left(\Delta_1 \oplus \Delta_2\right)(x)= \begin{cases}\Delta_1(x) & \text { if } x \in \operatorname{dom}\left(\Delta_1\right)\backslash \operatorname{dom}\left(\Delta_2\right) \\ \Delta_2(x) & \text { if } x \in \operatorname{dom}\left(\Delta_2\right) \backslash \operatorname{dom}\left(\Delta_1\right) \\ \Delta_1(x) \oplus \Delta_2(x) & \text { if } x\in \operatorname{dom}\left(\Delta_1\right) \cap \operatorname{dom}\left(\Delta_2\right) \\ \text {undefined } & \text { if } x \notin \operatorname{dom}\left(\Delta_1\right) \cup \operatorname{dom}\left(\Delta_2\right)\end{cases}
$$

$$
\operatorname{Ch}\left(t, !\right)+\operatorname{Ch}(t, ?)=\operatorname{Ch}\left(t, \ddagger\right)
$$



\begin{figure}[!b]
{\small

\begin{flalign*}
 &\text{\textbf{Subtyping}} & \fbox{$\Gamma \vdash \tau <: \tau$}
\end{flalign*}
\\ \
\begin{prooftree}
\hypo{\eraserf{\Gamma} = \overline{x_i{:}t_i} \quad  \models \forall \overline{x_i{:}t_i}.\forall v{:}t. \denotation{\Gamma} \implies (\phi_1\implies\phi_2)  }
\infer1[\textsc{Sub-Base}]{
\Gamma \vdash \{v: t ~|~\phi_1\} <: \{v: t ~|~\phi_2\}
}
\end{prooftree}
\\ \ \\ \ \\ \
\begin{prooftree}
\hypo{ \ctx{\Gamma}{\Delta} \vdash \tau_1 <: \tau_2 }
\infer1[\textsc{Sub-Ch-Out}]{
\ctx{\Gamma}{\Delta} \vdash \chT{\tau_1,!} <: \chT{\tau_2,!}
}
\end{prooftree}
\quad
\begin{prooftree}
\hypo{ \ctx{\Gamma}{\Delta} \vdash \tau_2 <: \tau_1 }
\infer1[\textsc{Sub-Ch-In}]{
\ctx{\Gamma}{\Delta} \vdash \chT{\tau_1,?} <: \chT{\tau_2,?}
}
\end{prooftree}
{\small
\begin{flalign*}
 &\text{\textbf{Message Typing}} & \fbox{$ \ctx{\Gamma}{\Delta} \vdash M : \tau$}
\end{flalign*}
}
\\ \
\begin{prooftree}
\hypo{(x, \tau) \in \Gamma}
\infer1[\textsc{MT-Var1}]{
\ctx{\Gamma}{\emptyset} \vdash x : \tau 
}
\end{prooftree}
\quad
\begin{prooftree}
\hypo{}
\infer1[\textsc{MT-Var2}]{
\ctx{\Gamma}{x{:}\tau} \vdash x : \tau 
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{\ctx{\Gamma}{\Delta_1} \vdash m :  \tau_1}
\hypo{\ctx{\Gamma,x{:}\tau_1}{\Delta_2} \vdash n :  \tau_2}
\infer2[\textsc{MT-Pair1}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash (m, n) : x{:} \tau_1 \times  \tau_2
}
\end{prooftree}
\quad
\begin{prooftree}
\hypo{\ctx{\Gamma}{\Delta_1} \vdash m :  \tau_1}
\hypo{\ctx{\Gamma}{\Delta_2,x{:}\tau_1} \vdash n :  \tau_2}
\infer2[\textsc{MT-Pair2}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash (m, n) : x{:} \tau_1 \times  \tau_2
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta} \vdash M : \tau \quad
\ctx{\Gamma}{\emptyset} \vdash K : \keyT{\tau_k}\quad \eraserf{\tau_k} = b
}
\infer1[\textsc{MT-Encrypt}]{
\ctx{\Gamma}{\Delta} \vdash \{M\}_K : \{\tau\}
}
\end{prooftree}
\quad
\begin{prooftree}
\hypo{\ctx{\Gamma}{\Delta} \vdash e : \tau_1 \quad \ctx{\Gamma}{\Delta} \vdash \tau_1 <: \tau_2 }
\infer1[\textsc{T-Sub}]{
\ctx{\Gamma}{\Delta} \vdash e : \tau_2
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{\ctx{\Gamma}{\Delta_1} \vdash e : \tau_1 \quad \Delta_1 \subseteq \Delta_2 }
\infer1[\textsc{T-Delta}]{
\ctx{\Gamma}{\Delta_2} \vdash e : \tau
}
\end{prooftree}
\ \\ \ \\ \ \\
{\small
\begin{flalign*}
 &\text{\textbf{Process Typing}} & \fbox{$\Gamma | \Delta \vdash P$}
\end{flalign*}
}
\\ \

\begin{comment}
\end{comment}
}
\end{figure}

\begin{figure}[!b]
{\small
\begin{prooftree}
\hypo{}
\infer1[\textsc{T-Zero}]{
\emptyset \vdash 0
}
\end{prooftree}
\quad
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash x : \chT{\tau_1, !} \quad
\ctx{\Gamma}{\Delta_2}\vdash y : \tau_2 \quad  \ctx{\Gamma}{\Delta_3} \vdash P \quad
\ctx{\Gamma}{\Delta_2} \vdash \tau_2 <: \tau_1
}
\infer1[\textsc{T-Out}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2 \oplus \Delta_3}\vdash x!y.P
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash x : \chT{\tau_1, ?} \quad
\neg Linear(\eraserf{\tau_2})
\quad
\ctx{\Gamma, y:\tau_2}{\Delta_2} \vdash P \quad
\ctx{\Gamma}{\Delta_1} \vdash \chT{\tau_1, ?} <: \chT{\tau_2, ?}
}
\infer1[\textsc{T-In1}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash x?y.P
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash x : \chT{\tau_1, ?} \quad
Linear(\eraserf{\tau_2})
\quad
\ctx{\Gamma}{\Delta_2, y:\tau_2} \vdash P
\quad
\ctx{\Gamma}{\Delta_1} \vdash \chT{\tau_1, ?} <: \chT{\tau_2, ?}
}
\infer1[\textsc{T-In2}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash x?y.P
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{
\ctx{\Gamma, x: \tau}{\Delta} \vdash P \quad
\neg Linear(\eraserf{\tau})
}
\infer1[\textsc{T-New1}]{
\ctx{\Gamma}{\Delta} \vdash (\nu x).P}
\end{prooftree}
\quad
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta, x: \chT{\tau, \ddagger}} \vdash P 
}
\infer1[\textsc{T-New2}]{
\ctx{\Gamma}{\Delta} \vdash (\nu x).P}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{ 
\ctx{\Gamma}{\Delta}\vdash P
 }
 \hypo{ 
 \eraserf{\ctx{\Gamma}{\Delta}} = \overline{x_i{:}t_i} \quad  \models \forall \overline{x_i{:}t_i}.\denotation{\ctx{\Gamma}{\Delta}} \implies \phi
 }
\infer2[\textsc{T-Assert}]{
\ctx{\Gamma}{\Delta} \vdash \assertP{\phi}.P
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{ 
\Gamma, \_: \nuot{unit}{\phi} |\Delta \vdash P}
\infer1[\textsc{T-Check}]{
\ctx{\Gamma}{\Delta} \vdash \checkP{\phi}.P
}
\end{prooftree}
\quad
\begin{prooftree}
\hypo{ 
\ctx{\Gamma}{\Delta_1} \vdash P_1 \quad
\ctx{\Gamma}{\Delta_2} \vdash P_2
 }
\infer1[\textsc{T-Par}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash P_1 {||} P_2
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash M : \{\tau\} \quad
\Gamma \vdash k : \keyT{\tau} \quad\eraserf{\tau} = b \quad
\neg Linear(\eraserf{\tau})
\quad
\ctx{\Gamma, x:\tau}{\Delta_2}  \vdash P 
 }
\infer1[\textsc{T-Decrypt1}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash \decryptP{M}{x}{k}.P
}
\end{prooftree}
\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash M : \{\tau\} \quad
\Gamma \vdash k : \keyT{\tau} \quad\eraserf{\tau} = b \quad
Linear(\eraserf{\tau})
\quad
\ctx{\Gamma}{\Delta_2,x:\tau}  \vdash P 
 }
\infer1[\textsc{T-Decrypt2}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash \decryptP{M}{x}{k}.P
}
\end{prooftree}

\ \\ \ \\ \ \\
\begin{prooftree}
\hypo{
\forall i \ \ctx{\Gamma}{\Delta_i} \vdash P_i    \quad
\mathit{DOM}(\Gamma) = N \quad
\mathit{DOM}(\Delta_1 \bigoplus ... \bigoplus \Delta_i) = C
 }
\infer1[\textsc{T-Config}]{
 \vdash \langle\{P_1, ...,P_n \}, N, C\rangle
}
\end{prooftree}
\ \\ \ \\ \ \\


\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash M : \tau \quad 
\ctx{\Gamma, x{:}\tau}{\Delta_2} \vdash P
 }
\infer1[\textsc{T-Let1}]{
\ctx{\Gamma}{\Delta} \vdash 
}
\end{prooftree}
\quad
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash M : \tau \quad 
\ctx{\Gamma}{\Delta_2, x{:}\tau} \vdash P
 }
\infer1[\textsc{T-Let2}]{
\ctx{\Gamma}{\Delta} \vdash \letP{x}{M}{P}
}
\end{prooftree}
}


\end{figure}



\section{Metatheory}\label{sec-structure}
\paragraph{Soundness}If $\emptyset | \emptyset \vdash$ P  then P is safe 

\paragraph{Safety} A process P is safe iff $\langle\{P\}, \emptyset, \emptyset\rangle \not\longrightarrow^* \textbf{AssertFailure} $ .


\paragraph{Lemma Inversion-Out}  If $\Gamma | \Delta \vdash x!y.P$, then  exists $\Delta_1 , \Delta_2 $ and $\Delta_3$ such that $\Delta_1 \oplus \Delta_2 \oplus \Delta_3=\Delta $ and $\Gamma|\Delta_1 \vdash x : \chT{\tau_1, !}$ , $ \Gamma|\Delta_2  \vdash y : \tau_2 $  $
\Gamma|\Delta_3 \vdash P$ and $\Gamma | \Delta_2 \vdash \tau_2 <: \tau_1$  holds.

\paragraph{Proof}  According to typing rule \textsc{T-out}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash x : \chT{\tau_1, !} \quad
\ctx{\Gamma}{\Delta_2}\vdash y : \tau_2 \quad  \ctx{\Gamma}{\Delta_3} \vdash P \quad
\ctx{\Gamma}{\Delta_2} \vdash \tau_2 <: \tau_1
}
\infer1[\textsc{T-Out}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2 \oplus \Delta_3}\vdash x!y.P
}

\end{prooftree}
\ \\ \ \\ \ 
Since $\Gamma | \Delta \vdash x!y.P$, exists $\Delta_1 , \Delta_2 $ and $\Delta_3$ such that $\Delta_1 \oplus \Delta_2 \oplus \Delta_3=\Delta $ and $\Gamma|\Delta_1 \vdash x : \chT{\tau_1, !}$ , $ \Gamma|\Delta_2  \vdash y : \tau_2 $  $
\Gamma|\Delta_3 \vdash P$ and $\Gamma | \Delta_2 \vdash \tau_2 <: \tau_1$ holds.

\qed

     



\paragraph{Lemma Inversion-In1}  If $\Gamma | \Delta \vdash x?y.P$, then exists $\Delta_1$ and $\Delta_2 $ such that $\Delta_1 \oplus \Delta_2 =\Delta $ , $\Gamma|\Delta_1 \vdash x : \chT{\tau_1, ?}$ , $\neg Linear(\eraserf{\tau_1})$ ,$\Gamma, y : \tau_2|\Delta_2  \vdash P$ and $\Gamma|\Delta_1 \vdash \chT{\tau_1, ?} <: \chT{\tau_2, ?}$ holds.

\paragraph{Proof}  According to typing rule \textsc{T-in1}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash x : \chT{\tau_1, ?} \quad
\neg Linear(\eraserf{\tau_1})
\quad
\ctx{\Gamma, y:\tau_2}{\Delta_2} \vdash P \quad
\ctx{\Gamma}{\Delta_1} \vdash \chT{\tau_1, ?} <: \chT{\tau_2, ?}
}
\infer1[\textsc{T-In1}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash x?y.P
}
\end{prooftree}
\ \\ \ \\ \ 
Since $\Gamma | \Delta \vdash x?y.P$, exists $\Delta_1$ and $\Delta_2 $ such that $\Delta_1 \oplus \Delta_2 =\Delta $ , $\Gamma|\Delta_1 \vdash x : \chT{\tau_1, ?}$ , $\neg Linear(\eraserf{\tau_1})$ ,$\Gamma, y : \tau_2|\Delta_2  \vdash P$ and $\Gamma|\Delta_1 \vdash \chT{\tau_1, ?} <: \chT{\tau_2, ?}$ holds
\qed

\paragraph{Lemma Inversion-In2}  If $\Gamma | \Delta \vdash x?y.P$, then exists $\Delta_1$ and $\Delta_2 $ such that $\Delta_1 \oplus \Delta_2 =\Delta $ , $\Gamma|\Delta_1 \vdash x : \chT{\tau_1, ?}$ , $
\Gamma|\Delta_2, y : \tau_2  \vdash P$ $ Linear(\eraserf{\tau_1})$ ,$\Gamma, y : \tau_2|\Delta_2  \vdash P$ and $\Gamma|\Delta_1 \vdash \chT{\tau_1, ?} <: \chT{\tau_2, ?}$ holds.
\paragraph{Proof}  According to typing rule \textsc{T-in2}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash x : \chT{\tau_1, ?} \quad
Linear(\eraserf{\tau_1})
\quad
\ctx{\Gamma}{\Delta_2, y:\tau_2} \vdash P
\quad
\ctx{\Gamma}{\Delta_1} \vdash \chT{\tau_1, ?} <: \chT{\tau_2, ?}
}
\infer1[\textsc{T-In2}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash x?y.P
}
\end{prooftree}
\ \\ \ \\ \ 
Since $\Gamma | \Delta \vdash x?y.P$, then exists $\Delta_1$ and $\Delta_2 $ such that $\Delta_1 \oplus \Delta_2 =\Delta $ , $\Gamma|\Delta_1 \vdash x : \chT{\tau_1, ?}$ , $
\Gamma|\Delta_2, y : \tau_2  \vdash P$ $ Linear(\eraserf{\tau_1})$ ,$\Gamma, y : \tau_2|\Delta_2  \vdash P$ and $\Gamma|\Delta_1 \vdash \chT{\tau_1, ?} <: \chT{\tau_2, ?}$ holds.
\qed

\paragraph{Lemma Inversion-Par}  If $\Gamma | \Delta \vdash P_1||P_2$, then there exists $\Delta_1 \oplus \Delta_2 =\Delta $ such that $\Gamma|\Delta_1 \vdash P_1$ and $
\Gamma|\Delta_2 \vdash P_2$ hold.
\paragraph{Proof}  According to typing rule \textsc{T-Par}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{ 
\ctx{\Gamma}{\Delta_1} \vdash P_1 \quad
\ctx{\Gamma}{\Delta_2} \vdash P_2
 }
\infer1[\textsc{T-Par}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash P_1 {||} P_2
}
\end{prooftree}
\ \\ \ \\ \ 
Since $\Gamma | \Delta \vdash P_1||P_2$, then there exists $\Delta_1 \oplus \Delta_2 =\Delta $ such that $\Gamma|\Delta_1 \vdash P_1$ and $
\Gamma|\Delta_2 \vdash P_2$ hold.
\qed

\paragraph{Lemma Inversion-New1}  If $\Gamma | \Delta \vdash (\nu \tau).P$, and $\tau$ is not of the form $\chT{\tau, \ddagger}$, then exists $\tau$ such that $\Gamma, x : \tau |\Delta \vdash P$ and $\neg Linear(\eraserf{\tau})$ hold.
\paragraph{Proof}  According to typing rule \textsc{T-New1}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{
\ctx{\Gamma, x: \tau}{\Delta} \vdash P \quad
\neg Linear(\eraserf{\tau})
}
\infer1[\textsc{T-New1}]{
\ctx{\Gamma}{\Delta} \vdash (\nu x).P}
\end{prooftree}
\ \\ \ \\ \ 
Since  $\Gamma | \Delta \vdash (\nu \tau).P$, and $\tau$ is not of the form $\chT{\tau, \ddagger}$, then exists $\tau$ such that $\Gamma, x : \tau |\Delta \vdash P$ and $\neg Linear(\eraserf{\tau})$ hold.
\qed

\paragraph{Lemma Inversion-New2}  If $\Gamma | \Delta \vdash (\nu \tau).P$,$\tau$ is of the form $\chT{\tau, \ddagger}$, then exists $\tau$ such that $\Gamma |\Delta, x : \tau  \vdash P$ and $ Linear(\eraserf{\tau})$ hold.
\paragraph{Proof}  According to typing rule \textsc{T-New2}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta, x: \chT{\tau, \ddagger}} \vdash P \quad
Linear(\eraserf{\tau})
}
\infer1[\textsc{T-New2}]{
\ctx{\Gamma}{\Delta} \vdash (\nu x).P}
\end{prooftree}
\ \\ \ \\ \ 
Since $\Gamma | \Delta \vdash (\nu \tau).P$,$\tau$ is of the form $\chT{\tau, \ddagger}$, then exists $\tau$ such that $\Gamma |\Delta, x : \tau  \vdash P$ and $ Linear(\eraserf{\tau})$ hold.
\qed

\paragraph{Lemma Inversion-Check}  If $\Gamma | \Delta \vdash \checkP{\phi}.P$, then exists $ \nuot{unit}{\phi} $ such that $\Gamma, \_:\nuot{unit}{\phi} | \Delta \vdash P$ hold.
\paragraph{Proof}  According to typing rule \textsc{T-Check}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{ 
\Gamma, \_: \nuot{unit}{\phi} |\Delta \vdash P}
\infer1[\textsc{T-Check}]{
\ctx{\Gamma}{\Delta} \vdash \checkP{\phi}.P
}
\end{prooftree}
\ \\ \ \\ \ 
Since  $\Gamma | \Delta \vdash \checkP{\phi}.P$, then exists $ \nuot{unit}{\phi} $ such that $\Gamma, \_:\nuot{unit}{\phi} | \Delta \vdash P$ hold.
\qed

\paragraph{Lemma Inversion-Assert}  If $\Gamma | \Delta \vdash \assertP{\phi}.P$, then exists $ x_i{:}t_i $ such that  $\Gamma | \Delta \vdash P$, 
$\eraserf{\Gamma | \Delta} =\overline{x_i{:}t_i}$ 
and  
$\models \forall \overline{x_i{:}t_i}.\denotation{\Gamma|\Delta} \implies \phi$
hold.

\paragraph{Proof}  According to typing rule \textsc{T-Assert}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{ 
\ctx{\Gamma}{\Delta}\vdash P
 }
 \hypo{ 
 \eraserf{\ctx{\Gamma}{\Delta}} = \overline{x_i{:}t_i} \quad  \models \forall \overline{x_i{:}t_i}.\denotation{\ctx{\Gamma}{\Delta}} \implies \phi
 }
\infer2[\textsc{T-Assert}]{
\ctx{\Gamma}{\Delta} \vdash \assertP{\phi}.P
}
\end{prooftree}
\ \\ \ \\ \ 
Since  $\Gamma | \Delta \vdash \assertP{\phi}.P$, then exists $ x_i{:}t_i $ such that  $\Gamma | \Delta \vdash P$, 
$\eraserf{\Gamma | \Delta} =\overline{x_i{:}t_i}$ 
and  
$\models \forall \overline{x_i{:}t_i}.\denotation{\Gamma|\Delta} \implies \phi$
hold.
\qed

\paragraph{Lemma Inversion-Decrypt1}  If $\Gamma |\Delta \vdash \decryptP{M}{x}{k}.P$, and $\Gamma (k)$ is not of the form $Key(\chT{\tau, \ddagger}) $,then exists $\tau$, $\Delta_1$ and $\Delta_2 $ such that $\Delta_1 \oplus \Delta_2 =\Delta $ ,  $\Gamma|\Delta_1 \vdash M : \{\tau\}$, $\Gamma \vdash k : \keyT{\tau}$, $\neg Linear(\eraserf{\tau}$) and  $\Gamma, x:\tau | \Delta_2  \vdash P $ hold.
\paragraph{Proof}  According to typing rule \textsc{T-Decrypt1}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash M : \{\tau\} \quad
\Gamma \vdash k : \keyT{\tau} \quad\eraserf{\tau} = b \quad
\neg Linear(\eraserf{\tau})
\quad
\ctx{\Gamma, x:\tau}{\Delta_2}  \vdash P 
 }
\infer1[\textsc{T-Decrypt1}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash \decryptP{M}{x}{k}.P
}
\end{prooftree}
\ \\ \ \\ \ 
Since $\Gamma |\Delta \vdash \decryptP{M}{x}{k}.P$, and $\Gamma (k)$ is not of the form $Key(\chT{\tau, \ddagger}) $,then exists $\tau$, $\Delta_1$ and $\Delta_2 $ such that $\Delta_1 \oplus \Delta_2 =\Delta $ ,  $\Gamma|\Delta_1 \vdash M : \{\tau\}$, $\Gamma \vdash k : \keyT{\tau}$, $\neg Linear(\eraserf{\tau}$) and  $\Gamma, x:\tau | \Delta_2  \vdash P $ hold.
\qed

\paragraph{Lemma Inversion-Decrypt2}  If $\Gamma |\Delta \vdash \decryptP{M}{x}{k}.P$,and $\Gamma (k)$ is of the form $Key(\chT{\tau, \ddagger}) $, then exists $\tau$, $\Delta_1$ and $\Delta_2 $ such that $\Delta_1 \oplus \Delta_2 =\Delta $ ,   $\Gamma|\Delta_1 \vdash M : \{\tau\}$, $\Gamma \vdash k : \keyT{\tau}$, $ Linear(\eraserf{\tau}$ and  $\Gamma | \Delta_2, x:\tau  \vdash P $ hold.
\paragraph{Proof}  According to typing rule \textsc{T-Decrypt2}
\ \\ \ \\ \ 
\begin{prooftree}
\hypo{
\ctx{\Gamma}{\Delta_1} \vdash M : \{\tau\} \quad
\Gamma \vdash k : \keyT{\tau} \quad\eraserf{\tau} = b \quad
Linear(\eraserf{\tau})
\quad
\ctx{\Gamma}{\Delta_2,x:\tau}  \vdash P 
 }
\infer1[\textsc{T-Decrypt2}]{
\ctx{\Gamma}{\Delta_1 \oplus \Delta_2} \vdash \decryptP{M}{x}{k}.P
}
\end{prooftree}
\ \\ \ \\ \ 
Since  $\Gamma |\Delta \vdash \decryptP{M}{x}{k}.P$,and $\Gamma (k)$ is of the form $Key(\chT{\tau, \ddagger}) $, then exists $\tau$, $\Delta_1$ and $\Delta_2 $ such that $\Delta_1 \oplus \Delta_2 =\Delta $ ,   $\Gamma|\Delta_1 \vdash M : \{\tau\}$, $\Gamma \vdash k : \keyT{\tau}$, $ Linear(\eraserf{\tau}$ and  $\Gamma | \Delta_2, x:\tau  \vdash P $ hold.
\qed

\paragraph{Substitution Lemma-$\Gamma$} If  $ \Gamma, x:S | \Delta \vdash t : T $ and $ \Gamma | \Delta \vdash  s:S,$  then $ \Gamma| \Delta \vdash [x \mapsto s ]t :T.  $

\paragraph{Substitution Lemma-$\Delta$} If  $ \Gamma| \Delta, x:S \vdash t : T $ and $ \Gamma| \Delta \vdash  s:S,$  then $ \Gamma| \Delta \vdash [x \mapsto s ]t :T.  $

\paragraph{Preservation} For all $\langle\{P_1, ...,P_n \}, N, C\rangle \longrightarrow \langle\{P_1', ..., P_n' \}, N', C'\rangle$ and $\forall i. \Gamma | \Delta_i \vdash P_1, ...,P_n$ where $\mathit{DOM}(\bigoplus \Delta_i) = C$, then there exists $\Gamma'$ and $\{\Delta_i'\}$, such that, $\forall i. \Gamma' | \Delta_i' \vdash P_1', ..., P_n'$ and $\mathit{DOM}(\bigoplus \Delta_i') = C'$.

\paragraph{Proof.}

\paragraph{Case \textsc{Step-In-Out}} For the case
\begin{align*}
    \langle\Psi \uplus\{x?y.P_1, x!z.P_2\}, N, C\rangle &\longrightarrow \langle\Psi \uplus\{[z / y]P_1, P_2\}, N, C \setminus \{x\}\rangle
\end{align*}\noindent
We have
\begin{align}
    &\Gamma | \Delta_1 \vdash x?y.P_1
    \\&\Gamma | \Delta_2 \vdash x!z.P_2
    \\&DOM(\Delta_1 \oplus \Delta_2) = C
\end{align}\noindent
According to typing rule Lemma Inversion-Out, \textsc{Sub-Ch-Out}, \textsc{T-Sub} and (2), we know there exists $\tau, \tau_x$
\begin{align}
    &\Gamma | \Delta_1 \vdash z : \tau
    \\&\Gamma | \Delta_1 \vdash x : \chT{\tau, !}
    \\&\Delta_1(x) = \chT{\tau_x, !}
    \\&\Gamma | \Delta_1 \vdash \tau <: \tau_x
\end{align}\noindent
\paragraph{Case1}
According to typing rule Lemma Inversion-In1, \textsc{Sub-Ch-In} and (1), we know
\begin{align}
    &\Gamma | \Delta_2 \vdash x : \chT{\tau', ?}
    \\&\Gamma, y{:}\tau' | \Delta_2 \vdash P 
    \\&\Delta_1(x) = \chT{\tau_x, ?}
     \\&\Gamma | \Delta_2 \vdash \tau_x <: \tau'
\end{align}\noindent
% According to Lemma \textsc{Inversion-In} and (1), we know there exists $\Gamma_1'$ and $\Delta_1'$ such that 
% \begin{align}
%     &\Gamma_1' | \Delta_1' \vdash P_1
% \end{align}\noindent
According to transitivity and \textsc{T-Sub}, we have
\begin{align}
    &\Gamma | \Delta_1 \vdash \tau <: \tau'
    \\&\Gamma, y{:}\tau | \Delta_2 \vdash P
\end{align}\noindent
According to Substitution Lemma-$\Gamma$, (4) and (13), we have
\begin{align}
    &\Gamma | \Delta_1 \vdash P_1[y \mapsto z]
\end{align}\noindent
\paragraph{Case2} According to typing rule Lemma Inversion-In2, \textsc{Sub-Ch-In} and (1), we know
\begin{align}
    &\Gamma | \Delta_2 \vdash x : \chT{\tau', ?}
    \\&\Gamma| \Delta_2, y{:}\tau'  \vdash P 
    \\&\Delta_1(x) = \chT{\tau_x, ?}
     \\&\Gamma | \Delta_2 \vdash \tau_x <: \tau'
\end{align}\noindent
% According to Lemma \textsc{Inversion-In} and (1), we know there exists $\Gamma_1'$ and $\Delta_1'$ such that 
% \begin{align}
%     &\Gamma_1' | \Delta_1' \vdash P_1
% \end{align}\noindent
According to transitivity and \textsc{T-Sub}, we have
\begin{align}
    &\Gamma | \Delta_1 \vdash \tau <: \tau'
    \\&\Gamma| \Delta_2, y{:}\tau  \vdash P
\end{align}\noindent
According to Substitution Lemma-$\Delta$, (4) and (20), we have
\begin{align}
    &\Gamma | \Delta_1 \vdash P_1[y \mapsto z]
\end{align}\noindent
We can deduce that $\Gamma' = \Gamma$. $\Delta_1' = \Delta_1 \setminus \{x\}$, $\Delta_2' = \Delta_2 \setminus \{x\}$. $P_1' = P_1[y \mapsto z]$, $P_2' = P_2$. We need to prove
\begin{align*}
    &\Gamma' | \Delta_1' \vdash P_1[y \mapsto z]
    \\&\Gamma' | \Delta_2' \vdash P_2
    \\&DOM(\Delta_1' \oplus \Delta_2') = C \setminus \{x\}
\end{align*}\noindent
It follow from $\Delta_1' = \Delta_1 \setminus \{x\}$, $\Delta_2' = \Delta_2 \setminus \{x\}$ that  $DOM(\Delta_1' \oplus \Delta_2') = C \setminus \{x\}$ holds. 
\\By invoking the substitution lemma-$\Gamma$, substitution lemma-$\Delta$ and applying the typing rules \textsc{T-IN1}, typing rules \textsc{T-IN2}, we can  prove that $\Gamma' | \Delta_1' \vdash P_1[y \mapsto z] $ holds.
\\Based on the established typing rules \textsc{T-OUT}, we can rigorously prove that $\Gamma | \Delta_2' \vdash P_2 $ holds true. This completes the proof.\\

\qed

\paragraph{Case \textsc{Step-Parallel}} For the case
\begin{align*}
  \langle\Psi \uplus\{P \mid Q\}, N, C\rangle &\longrightarrow\langle\Psi \uplus\{P, Q\}, N, C\rangle 
\end{align*}\noindent
We have
\begin{align}
    &\Gamma | \Delta_1 \vdash P
    \\&\Gamma | \Delta_2 \vdash  Q
    \\&DOM(\Delta_1) = C 
\end{align}\noindent
We obtain $\Gamma' = \Gamma$. $\Delta_1' = \Delta_1 $, $\Delta_2' = \Delta_2 $. $P' = P$, $Q' = Q$. We need to prove
\begin{align*}
    &\Gamma' | \Delta_1' \vdash P
    \\&\Gamma' | \Delta_2' \vdash  Q
    \\&DOM(\Delta_1') = C 
\end{align*}\noindent
It follow from $\Delta_1' = \Delta_1 $, $\Delta_2' = \Delta_2 $ that  $DOM(\Delta_1' \oplus \Delta_2') = C $ holds
\\By applying the \textsc{Lemma Inversion-Par}  we can establish that  $ \Gamma | \Delta_1' \vdash P, \Gamma | \Delta_2' \vdash  Q $ holds. This completes the proof.\\
\qed

\paragraph{Case \textsc{Step-New-Fresh}} For the case
\begin{align*}
  \langle\Psi \uplus\{(\nu x) P\}, N, C\rangle &\longrightarrow\langle\Psi \uplus\{[y / x] P\}, N \cup \{y\}, C\rangle \quad \text{ $y$ is fresh} 
\end{align*}\noindent
We have
\begin{align}
    &\Gamma | \Delta_1 \vdash (\nu x)P
    \\&DOM(\Delta_1) = C 
\end{align}\noindent
According to Lemma Inversion-New1 and (25), we have
\begin{align}
    &\Gamma, x : \tau |\Delta \vdash P  
\end{align}\noindent
According to Substitution Lemma-$\Gamma$ and (27), we have
\begin{align}
    &\Gamma | \Delta_1 \vdash P[x \mapsto y]  
\end{align}\noindent
We obtain $\Gamma' = \Gamma \cup \{y\} $. $\Delta_1' = \Delta_1 $. $P' = P[x \mapsto y]$. We need to prove
\begin{align*}
    &\Gamma | \Delta_1 \vdash P[x \mapsto y]
    \\&DOM(\Delta_1') = C 
\end{align*}\noindent
It follow from $\Delta_1' = \Delta_1 $,that  $DOM(\Delta_1' ) = C $ holds.
\\Based on the Lemma Inversion-New1 and Substitution Lemma-$\Gamma$, we can rigorously prove that $\Gamma | \Delta_1 \vdash P[x \mapsto y] $ holds true. This completes the proof.\\

\qed

\paragraph{Case \textsc{Step-New-Channel}} For the case
\begin{align*}
  \langle\Psi \uplus\{(\nu_C x) P\}, N, C\rangle &\longrightarrow\langle\Psi \uplus\{[y / x] P\}, N, C \cup \{y\}\rangle \quad \text{ $y$ is channel} 
\end{align*}\noindent
We have
\begin{align}
    &\Gamma | \Delta_1 \vdash (\nu_C x)P
    \\&DOM(\Delta_1) = C 
\end{align}\noindent
According to Lemma Inversion-New2 and (29), we have
\begin{align}
    &\Gamma |\Delta, x : \tau \vdash P  
\end{align}\noindent
According to Substitution Lemma-$\Delta$ and (31), we have
\begin{align}
    &\Gamma | \Delta_1 \vdash P[x \mapsto y]  
\end{align}\noindent
We obtain $\Gamma' = \Gamma  $. $\Delta_1' = \Delta_1 \cup \{y\} $. $P' = P[x \mapsto y]$. We need to prove
\begin{align*}
    &\Gamma | \Delta_1 \vdash P[x \mapsto y]
    \\&DOM(\Delta_1') = C \cup \{y\}
\end{align*}\noindent
It follow from $\Delta_1' = \Delta_1 \cup \{y\} $,that  $DOM(\Delta_1' ) = C \cup \{y\} $ holds
\\By applying the \textsc{Lemma Inversion-New2} and Substitution Lemma-$\Delta$, we can rigorously prove that $\Gamma | \Delta_1 \vdash P[x \mapsto y] $ holds true. This completes the proof.

\paragraph{Case \textsc{Step-Check-Hold}} For the case
\begin{align*}
\langle\Psi \uplus\{\text { \textbf{check} } \phi . P\} , N, C\rangle &\longrightarrow \langle\Psi \uplus\{P\} , N, C\rangle \quad \text{where $\phi$ holds}\\
\end{align*}\noindent
We have
\begin{align}
&\Gamma | \Delta_1 \vdash {\textbf{check} } \phi . P
    \\&DOM(\Delta_1) = C 
\end{align}\noindent
We obtain $\Gamma' = \Gamma$. $\Delta_1' = \Delta_1 $, . $P' = P$, . We need to prove
\begin{align*}
    &\Gamma' | \Delta_1' \vdash P
    \\&DOM(\Delta_1') = C 
\end{align*}\noindent
It follow from $\Delta_1' = \Delta_1 $ that  $DOM(\Delta_1') = C $ holds
\\By applying the {Lemma Inversion-Check}  we can establish that  $ \Gamma' | \Delta_1' \vdash P $ holds. This completes the proof.\\
\qed

\paragraph{Case \textsc{Step-Check-Nothold}} For the case
\begin{align*}
\langle\Psi \uplus\{\text { \textbf{check} } \phi . P\}, N, C\rangle &\longrightarrow \langle\Psi, N, C\rangle \quad \text{where $\phi$ not holds} 
\end{align*}\noindent


\paragraph{Case \textsc{Step-Assert-Hold}} For the case
\begin{align*}
\langle\Psi \uplus\{\text { \textbf{assert} } \phi . P\} , N, C\rangle&\longrightarrow \langle\Psi \uplus\{P\}, N, C\rangle \quad \text{when $\phi$ holds} \\
\end{align*}\noindent
We have
\begin{align}
&\Gamma | \Delta_1 \vdash {\textbf{assert} } \phi . P
    \\&DOM(\Delta_1) = C 
\end{align}\noindent
We obtain $\Gamma' = \Gamma$. $\Delta_1' = \Delta_1 $, . $P' = P$, . We need to prove
\begin{align*}
    &\Gamma' | \Delta_1' \vdash P
    \\&DOM(\Delta_1') = C 
\end{align*}\noindent
It follow from $\Delta_1' = \Delta_1 $ that  $DOM(\Delta_1') = C $ holds
\\By applying the {Lemma Inversion-Assert}  we can establish that  $ \Gamma' | \Delta_1' \vdash P $ holds. This completes the proof.\\
\qed

\paragraph{Case \textsc{Step-Decrypt}} For the case
\begin{align*}
\langle\Psi \uplus\{ \text{\textbf{decrypt}}\ \{M\}_K
\text{ is } \{x\}_K . P\} , N, C\rangle &\longrightarrow\langle\Psi \uplus\{[M / x] P\} , N, C \rangle \\
\end{align*}\noindent
We have
\begin{align}
    &\Gamma | \Delta_1 \vdash \textbf{decrypt}\ \{M\}_K
\text{ is } \{x\}_K . P
    \\&DOM(\Delta_1) = C 
\end{align}\noindent
According to Lemma Inversion-Decrypt1 and (37), we have
\begin{align}
    &\Gamma, x:\tau | \Delta_2  \vdash  P  
\end{align}\noindent
According to Substitution Lemma-$\Gamma$ and (39), we have
\begin{align}
    &\Gamma | \Delta_1 \vdash P[x \mapsto y]  
\end{align}\noindent
According to Lemma Inversion-Decrypt2 and (41), we have
\begin{align}
    &\Gamma| \Delta_2, x:\tau   \vdash  P  
\end{align}\noindent
According to Substitution Lemma-$\Gamma$ and (39), we have
\begin{align}
    &\Gamma | \Delta_1 \vdash P[x \mapsto y]  
\end{align}\noindent
We obtain $\Gamma' = \Gamma$. $\Delta_1' = \Delta_1 $, . $P' = P[x \mapsto M] $. We need to prove
\begin{align*}
    &\Gamma' | \Delta_1' \vdash P [x \mapsto M]
    \\&DOM(\Delta_1') = C 
\end{align*}\noindent
It follow from $\Delta_1' = \Delta_1 $ that  $DOM(\Delta_1') = C $ holds
\\By applying the Lemma Inversion-Decrypt1, Lemma Inversion-Decrypt2, Substitution Lemma-$\Gamma$ and Substitution Lemma-$\Delta$  we can establish that  $ \Gamma' | \Delta_1' \vdash P [x \mapsto M]$ holds. This completes the proof.\\
\qed



\section{Relative works}\label{sec-structure}

\section{Conclusion}\label{sec-structure}

 \end{document} 
